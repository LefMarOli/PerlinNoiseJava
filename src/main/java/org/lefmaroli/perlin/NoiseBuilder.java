package org.lefmaroli.perlin;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.lefmaroli.factorgenerator.MultipleFactorGenerator;
import org.lefmaroli.factorgenerator.MultiplierFactorGenerator;
import org.lefmaroli.factorgenerator.SingleFactorGenerator;
import org.lefmaroli.perlin.exceptions.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

public abstract class NoiseBuilder<NoiseType extends NoiseGenerator,
        NoiseBuilderType extends NoiseBuilder> {
    private static final Logger LOGGER = LogManager.getLogger(NoiseBuilder.class);
    private static final int INTERPOLATION_POINTS_UPPER_LIMIT = 50000;
    private static final MultiplierFactorGenerator DEFAULT_DISTANCE_GENERATOR = new MultiplierFactorGenerator(64, 0.5);
    private final NoiseBuilderType thisObj;
    private final int dimensions;
    protected int numberOfLayers = 5;
    protected long randomSeed = System.currentTimeMillis();
    private MultipleFactorGenerator distanceFactorGenerator;
    private SingleFactorGenerator amplitudeFactorGenerator = new MultiplierFactorGenerator(1.0, 0.5);

    public NoiseBuilder(int dimensions) {
        thisObj = self();
        this.dimensions = dimensions;
        this.distanceFactorGenerator =
                MultipleFactorGenerator.getSymmetricalFactorGenerator(dimensions, DEFAULT_DISTANCE_GENERATOR);
    }

    public NoiseBuilderType withDistanceFactorGenerator(SingleFactorGenerator distanceFactorGenerator) {
        LOGGER.warn("Generating symmetrical distanceFactorGenerators with provided SingleFactorGenerator for " +
                dimensions + " dimensions");
        return withDistanceFactorGenerator(
                MultipleFactorGenerator.getSymmetricalFactorGenerator(dimensions, distanceFactorGenerator));
    }

    public NoiseBuilderType withDistanceFactorGenerator(MultipleFactorGenerator distanceFactorGenerator) {
        if (dimensions != distanceFactorGenerator.getNumberOfFactors()) {
            throw new IllegalArgumentException(
                    "The number of factors generated by the provided multipleFactorsGenerator don't match the " +
                            "expected number of dimensions " + dimensions + " expected by this builder " +
                            thisObj.getClass().getSimpleName());
        }
        this.distanceFactorGenerator = distanceFactorGenerator;
        return thisObj;
    }

    public NoiseBuilderType withAmplitudeFactorGenerator(SingleFactorGenerator amplitudeFactorGenerator) {
        this.amplitudeFactorGenerator = amplitudeFactorGenerator;
        return thisObj;
    }

    public NoiseBuilderType withRandomSeed(long randomSeed) {
        this.randomSeed = randomSeed;
        return thisObj;
    }

    public NoiseBuilderType withNumberOfLayers(int numberOfLayers) {
        if (numberOfLayers < 1) {
            throw new IllegalArgumentException("Number of layers must be at least 1");
        }
        this.numberOfLayers = numberOfLayers;
        return thisObj;
    }

    public NoiseGenerator build() throws NoiseBuilderException {
        amplitudeFactorGenerator.reset();
        distanceFactorGenerator.reset();
        if (numberOfLayers == 1) {
            try {
                return buildSingleLayerNoise(getNextInterpolationPointCount(), amplitudeFactorGenerator.getNextFactor(),
                        randomSeed);
            } catch (InterpolationPointException e) {
                throw new NoiseBuilderException(e);
            }
        } else {
            return buildMultipleLayerNoise(generateNoiseLayers());
        }
    }

    protected abstract NoiseBuilderType self();

    protected abstract NoiseType buildSingleLayerNoise(List<Integer> interpolationPoints, double layerAmplitude,
                                                       long randomSeed)
            throws NoiseBuilderException;

    protected abstract NoiseType buildMultipleLayerNoise(List<NoiseType> layers)
            throws NoiseBuilderException;

    private static void assertInterpolationPointsCountForAll(List<Integer> interpolationPoints)
            throws InterpolationPointException {
        for (Integer interpolationPoint : interpolationPoints) {
            assertInterpolationPointsCount(interpolationPoint);
        }
    }

    private static void assertInterpolationPointsCount(int interpolationPoints) throws InterpolationPointException {
        if (interpolationPoints < 1) {
            throw new NoInterpolationPointException();
        } else if (interpolationPoints > INTERPOLATION_POINTS_UPPER_LIMIT) {
            throw new TooManyInterpolationPointsException(interpolationPoints, INTERPOLATION_POINTS_UPPER_LIMIT);
        }
    }

    private List<NoiseType> generateNoiseLayers() throws NoiseBuilderException {
        Random randomGenerator = new Random(randomSeed);
        List<NoiseType> layers = new ArrayList<>(numberOfLayers);
        for (int i = 0; i < numberOfLayers; i++) {
            long randomSeed = randomGenerator.nextLong();
            try {
                layers.add(generateNoiseLayer(i, randomSeed));
            } catch (NoiseLayerException e) {
                throw new NoiseBuilderException(e);
            }
        }
        return layers;
    }

    private NoiseType generateNoiseLayer(int layerNumber, long randomSeed)
            throws NoiseLayerException, NoiseBuilderException {
        List<Integer> interpolationPoints = getInterpolationPointsForLayer(layerNumber);
        return buildSingleLayerNoise(interpolationPoints, amplitudeFactorGenerator.getNextFactor(), randomSeed);
    }

    private List<Integer> getInterpolationPointsForLayer(int layerNumber) throws NoiseLayerException {
        try {
            return getNextInterpolationPointCount();
        } catch (InterpolationPointException e) {
            throw new NoiseLayerException.Builder(numberOfLayers, layerNumber).setCause(e).build();
        }
    }

    private List<Integer> getNextInterpolationPointCount() throws InterpolationPointException {
        List<Double> nextFactors = distanceFactorGenerator.getNextFactors();
        List<Integer> interpolationPoints = nextFactors.stream().map(Double::intValue).collect(Collectors.toList());
        assertInterpolationPointsCountForAll(interpolationPoints);
        return interpolationPoints;
    }
}
